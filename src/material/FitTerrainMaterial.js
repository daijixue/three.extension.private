class FitTerrainMaterial
{
    constructor() {

    }

    getMeshMaterial(mode) {
        if(mode === 1)
        {
            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 > z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 > z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 > z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 > z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 > z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 > z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 > z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 > z00 ? z22 : z00;',
                    '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }else if(mode === 3)
        {

            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 < z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 < z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 < z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 < z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 < z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 < z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 < z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 < z00 ? z22 : z00;',
                    '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }
        else if(mode === 2)
        {

            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z = orthographicDepthToViewZ(z , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }
        return new THREE.ShaderMaterial( {
            uniforms: {
                "size" : {value : 1},
                "scale": {value: 1},
                "diffuse" : {value: new THREE.Vector3(0,1,0)},
                "opacity" : {value: 1},
                "depthTexture": { value: null },
                "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                "textureMatrix": {value: null},
                "depthCameraNearFar": {value: null},
                "textureSize": {value: new THREE.Vector2(1,1)},
            },

            vertexShader:[
                'uniform float size;' ,
                'uniform float scale;' ,
                'uniform sampler2D depthTexture;',
                'uniform vec2 textureSize;',
                'uniform vec4 textureRange;',
                'uniform mat4 textureMatrix;',
                'uniform vec2 depthCameraNearFar;',
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_vertex>' ,
                '#include <fog_pars_vertex>' ,
                '#include <shadowmap_pars_vertex>' ,
                '#include <logdepthbuf_pars_vertex>' ,
                '#include <clipping_planes_pars_vertex>' ,
                'void main() {' ,
                '  #include <color_vertex>' ,
                '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                '     vec4 texCoord = textureMatrix*ps;',
                '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z01 < z00 ? z01 : z00;',
                '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z02 < z00 ? z02 : z00;',
                '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z10 < z00 ? z10 : z00;',
                '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                '     z00 = z11 < z00 ? z11 : z00;',
                '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z12 < z00 ? z12 : z00;',
                '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z20 < z00 ? z20 : z00;',
                '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z21 < z00 ? z21 : z00;',
                '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z22 < z00 ? z22 : z00;',
                '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                '  }',
                '  else {',
                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                '  }',
                '  #ifdef USE_SIZEATTENUATION' ,
                '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                '  #else' ,
                '    gl_PointSize = size;' ,
                '  #endif' ,
                '  #include <logdepthbuf_vertex>' ,
                '  #include <clipping_planes_vertex>' ,
                '  #include <worldpos_vertex>' ,
                '  #include <shadowmap_vertex>' ,
                '  #include <fog_vertex>' ,
                '  ',
                '}'
            ].join('\n'),

            fragmentShader: [
                'uniform vec3 diffuse;' ,
                'uniform float opacity;' ,
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_fragment>' ,
                '#include <map_particle_pars_fragment>' ,
                '#include <fog_pars_fragment>' ,
                '#include <shadowmap_pars_fragment>' ,
                '#include <logdepthbuf_pars_fragment>' ,
                '#include <clipping_planes_pars_fragment>' ,
                'void main() {' ,
                '  #include <clipping_planes_fragment>' ,
                '  vec3 outgoingLight = vec3( 0.0 );' ,
                '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                '  #include <logdepthbuf_fragment>' ,
                '  #include <map_particle_fragment>' ,
                '  #include <color_fragment>' ,
                '  #include <alphatest_fragment>' ,
                '  outgoingLight = diffuseColor.rgb;' ,
                '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                '  #include <premultiplied_alpha_fragment>' ,
                '  #include <tonemapping_fragment>' ,
                '  #include <encodings_fragment>' ,
                '  #include <fog_fragment>' ,
                '}'
            ].join('\n')
        } );
    }

    getLineMaterial(mode) {

        if(mode === 1)
        {
            // 贴合地面
            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 > z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 > z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 > z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 > z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 > z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 > z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 > z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 > z00 ? z22 : z00;',
                    '     z00 = z00 >0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }else if(mode === 3)
        {
            // 贴合地形高层
            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 < z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 < z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 < z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 < z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 < z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 < z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 < z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 < z00 ? z22 : z00;',
                    '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }else if(mode === 2)
        {
            // 正常
            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z =  orthographicDepthToViewZ(z , depthCameraNearFar[0], depthCameraNearFar[1]);',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }
        // 贴合地面
        return new THREE.ShaderMaterial( {
            uniforms: {
                "size" : {value : 1},
                "scale": {value: 1},
                "diffuse" : {value: new THREE.Vector3(0,1,0)},
                "opacity" : {value: 1},
                "depthTexture": { value: null },
                "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                "textureMatrix": {value: null},
                "depthCameraNearFar": {value: null},
                "textureSize": {value: new THREE.Vector2(1,1)},
            },

            vertexShader:[
                'uniform float size;' ,
                'uniform float scale;' ,
                'uniform sampler2D depthTexture;',
                'uniform vec2 textureSize;',
                'uniform vec4 textureRange;',
                'uniform mat4 textureMatrix;',
                'uniform vec2 depthCameraNearFar;',
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_vertex>' ,
                '#include <fog_pars_vertex>' ,
                '#include <shadowmap_pars_vertex>' ,
                '#include <logdepthbuf_pars_vertex>' ,
                '#include <clipping_planes_pars_vertex>' ,
                'void main() {' ,
                '  #include <color_vertex>' ,
                '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                '     vec4 texCoord = textureMatrix*ps;',
                '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z01 > z00 ? z01 : z00;',
                '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z02 > z00 ? z02 : z00;',
                '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z10 > z00 ? z10 : z00;',
                '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                '     z00 = z11 > z00 ? z11 : z00;',
                '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z12 > z00 ? z12 : z00;',
                '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z20 > z00 ? z20 : z00;',
                '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z21 > z00 ? z21 : z00;',
                '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z22 > z00 ? z22 : z00;',
                '     z00 = z00 > 0.9 ? 0.0: orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0, - 0.05,0.0);',
                '  }',
                '  else {',
                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                '  }',
                '  #ifdef USE_SIZEATTENUATION' ,
                '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                '  #else' ,
                '    gl_PointSize = size;' ,
                '  #endif' ,
                '  #include <logdepthbuf_vertex>' ,
                '  #include <clipping_planes_vertex>' ,
                '  #include <worldpos_vertex>' ,
                '  #include <shadowmap_vertex>' ,
                '  #include <fog_vertex>' ,
                '  ',
                '}'
            ].join('\n'),

            fragmentShader: [
                'uniform vec3 diffuse;' ,
                'uniform float opacity;' ,
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_fragment>' ,
                '#include <map_particle_pars_fragment>' ,
                '#include <fog_pars_fragment>' ,
                '#include <shadowmap_pars_fragment>' ,
                '#include <logdepthbuf_pars_fragment>' ,
                '#include <clipping_planes_pars_fragment>' ,
                'void main() {' ,
                '  #include <clipping_planes_fragment>' ,
                '  vec3 outgoingLight = vec3( 0.0 );' ,
                '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                '  #include <logdepthbuf_fragment>' ,
                '  #include <map_particle_fragment>' ,
                '  #include <color_fragment>' ,
                '  #include <alphatest_fragment>' ,
                '  outgoingLight = diffuseColor.rgb;' ,
                '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                '  #include <premultiplied_alpha_fragment>' ,
                '  #include <tonemapping_fragment>' ,
                '  #include <encodings_fragment>' ,
                '  #include <fog_fragment>' ,
                '}'
            ].join('\n')
        } );
    }

    getPointsMaterial(mode) {
        if(mode === 1)
        {
            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 > z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 > z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 > z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 > z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 > z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 > z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 > z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 > z00 ? z22 : z00;',
                    '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }else if(mode === 3)
        {

            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z01 < z00 ? z01 : z00;',
                    '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z02 < z00 ? z02 : z00;',
                    '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z10 < z00 ? z10 : z00;',
                    '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z00 = z11 < z00 ? z11 : z00;',
                    '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                    '     z00 = z12 < z00 ? z12 : z00;',
                    '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z20 < z00 ? z20 : z00;',
                    '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z21 < z00 ? z21 : z00;',
                    '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                    '     z00 = z22 < z00 ? z22 : z00;',
                    '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }
        else if(mode === 2)
        {

            return new THREE.ShaderMaterial( {
                uniforms: {
                    "size" : {value : 1},
                    "scale": {value: 1},
                    "diffuse" : {value: new THREE.Vector3(0,1,0)},
                    "opacity" : {value: 1},
                    "depthTexture": { value: null },
                    "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                    "textureMatrix": {value: null},
                    "depthCameraNearFar": {value: null},
                    "textureSize": {value: new THREE.Vector2(1,1)},
                },

                vertexShader:[
                    'uniform float size;' ,
                    'uniform float scale;' ,
                    'uniform sampler2D depthTexture;',
                    'uniform vec2 textureSize;',
                    'uniform vec4 textureRange;',
                    'uniform mat4 textureMatrix;',
                    'uniform vec2 depthCameraNearFar;',
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_vertex>' ,
                    '#include <fog_pars_vertex>' ,
                    '#include <shadowmap_pars_vertex>' ,
                    '#include <logdepthbuf_pars_vertex>' ,
                    '#include <clipping_planes_pars_vertex>' ,
                    'void main() {' ,
                    '  #include <color_vertex>' ,
                    '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                    '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                    '     vec4 texCoord = textureMatrix*ps;',
                    '     float z = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                    '     z = orthographicDepthToViewZ(z , depthCameraNearFar[0], depthCameraNearFar[1]);',

                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                    '  }',
                    '  else {',
                    '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                    '  }',
                    '  #ifdef USE_SIZEATTENUATION' ,
                    '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                    '  #else' ,
                    '    gl_PointSize = size;' ,
                    '  #endif' ,
                    '  #include <logdepthbuf_vertex>' ,
                    '  #include <clipping_planes_vertex>' ,
                    '  #include <worldpos_vertex>' ,
                    '  #include <shadowmap_vertex>' ,
                    '  #include <fog_vertex>' ,
                    '  ',
                    '}'
                ].join('\n'),

                fragmentShader: [
                    'uniform vec3 diffuse;' ,
                    'uniform float opacity;' ,
                    '#include <common>' ,
                    '#include <packing>' ,
                    '#include <color_pars_fragment>' ,
                    '#include <map_particle_pars_fragment>' ,
                    '#include <fog_pars_fragment>' ,
                    '#include <shadowmap_pars_fragment>' ,
                    '#include <logdepthbuf_pars_fragment>' ,
                    '#include <clipping_planes_pars_fragment>' ,
                    'void main() {' ,
                    '  #include <clipping_planes_fragment>' ,
                    '  vec3 outgoingLight = vec3( 0.0 );' ,
                    '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                    '  #include <logdepthbuf_fragment>' ,
                    '  #include <map_particle_fragment>' ,
                    '  #include <color_fragment>' ,
                    '  #include <alphatest_fragment>' ,
                    '  outgoingLight = diffuseColor.rgb;' ,
                    '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                    '  #include <premultiplied_alpha_fragment>' ,
                    '  #include <tonemapping_fragment>' ,
                    '  #include <encodings_fragment>' ,
                    '  #include <fog_fragment>' ,
                    '}'
                ].join('\n')
            } );
        }
        return new THREE.ShaderMaterial( {
            uniforms: {
                "size" : {value : 1},
                "scale": {value: 1},
                "diffuse" : {value: new THREE.Vector3(0,1,0)},
                "opacity" : {value: 1},
                "depthTexture": { value: null },
                "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                "textureMatrix": {value: null},
                "depthCameraNearFar": {value: null},
                "textureSize": {value: new THREE.Vector2(1,1)},
            },

            vertexShader:[
                'uniform float size;' ,
                'uniform float scale;' ,
                'uniform sampler2D depthTexture;',
                'uniform vec2 textureSize;',
                'uniform vec4 textureRange;',
                'uniform mat4 textureMatrix;',
                'uniform vec2 depthCameraNearFar;',
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_vertex>' ,
                '#include <fog_pars_vertex>' ,
                '#include <shadowmap_pars_vertex>' ,
                '#include <logdepthbuf_pars_vertex>' ,
                '#include <clipping_planes_pars_vertex>' ,
                'void main() {' ,
                '  #include <color_vertex>' ,
                '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                '  if(ps.x>=(textureRange[0]) && ps.x<=(textureRange[2]) && ps.y>=(textureRange[1])&& ps.y<=(textureRange[3])) {',
                '     vec4 texCoord = textureMatrix*ps;',
                '     float z00 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     float z01 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z01 < z00 ? z01 : z00;',
                '     float z02 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, -1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z02 < z00 ? z02 : z00;',
                '     float z10 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z10 < z00 ? z10 : z00;',
                '     float z11 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord));',
                '     z00 = z11 < z00 ? z11 : z00;',
                '     float z12 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 0.0, 0.0, 0.0)));',
                '     z00 = z12 < z00 ? z12 : z00;',
                '     float z20 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z20 < z00 ? z20 : z00;',
                '     float z21 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(0.0, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z21 < z00 ? z21 : z00;',
                '     float z22 = unpackRGBAToDepth(texture2DProj( depthTexture, texCoord - vec4(-1.0/textureSize.x, 1.0/textureSize.y, 0.0, 0.0)));',
                '     z00 = z22 < z00 ? z22 : z00;',
                '     z00 = z00 > 0.9 ? 0.0 : orthographicDepthToViewZ(z00 , depthCameraNearFar[0], depthCameraNearFar[1]);',

                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z00, 1.0 ) + vec4(0.0,0.0,-0.05,0.0);',
                '  }',
                '  else {',
                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                '  }',
                '  #ifdef USE_SIZEATTENUATION' ,
                '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                '  #else' ,
                '    gl_PointSize = size;' ,
                '  #endif' ,
                '  #include <logdepthbuf_vertex>' ,
                '  #include <clipping_planes_vertex>' ,
                '  #include <worldpos_vertex>' ,
                '  #include <shadowmap_vertex>' ,
                '  #include <fog_vertex>' ,
                '  ',
                '}'
            ].join('\n'),

            fragmentShader: [
                'uniform vec3 diffuse;' ,
                'uniform float opacity;' ,
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_fragment>' ,
                '#include <map_particle_pars_fragment>' ,
                '#include <fog_pars_fragment>' ,
                '#include <shadowmap_pars_fragment>' ,
                '#include <logdepthbuf_pars_fragment>' ,
                '#include <clipping_planes_pars_fragment>' ,
                'void main() {' ,
                '  #include <clipping_planes_fragment>' ,
                '  vec3 outgoingLight = vec3( 0.0 );' ,
                '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                '  #include <logdepthbuf_fragment>' ,
                '  #include <map_particle_fragment>' ,
                '  #include <color_fragment>' ,
                '  #include <alphatest_fragment>' ,
                '  outgoingLight = diffuseColor.rgb;' ,
                '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                '  #include <premultiplied_alpha_fragment>' ,
                '  #include <tonemapping_fragment>' ,
                '  #include <encodings_fragment>' ,
                '  #include <fog_fragment>' ,
                '}'
            ].join('\n')
        } );
    }


    getLabelMaterial() {
        return new THREE.ShaderMaterial( {
            uniforms: {
                "size" : {value : 1},
                "scale": {value: 1},
                "diffuse" : {value: new THREE.Vector3(0,1,0)},
                "opacity" : {value: 1},
                "depthTexture": { value: null },
                "textureRange": {value: new THREE.Vector4(0,0,0,0)},
                "textureMatrix": {value: null},
                "depthCameraNearFar": {value: null},
                "textureSize": {value: new THREE.Vector2(1,1)},
            },

            vertexShader:[
                'uniform float size;' ,
                'uniform float scale;' ,
                'uniform sampler2D depthTexture;',
                'uniform vec2 textureSize;',
                'uniform vec4 textureRange;',
                'uniform mat4 textureMatrix;',
                'uniform vec2 depthCameraNearFar;',
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_vertex>' ,
                '#include <fog_pars_vertex>' ,
                '#include <shadowmap_pars_vertex>' ,
                '#include <logdepthbuf_pars_vertex>' ,
                '#include <clipping_planes_pars_vertex>' ,
                'void main() {' ,
                '  #include <color_vertex>' ,
                '  vec4 ps = modelMatrix * vec4( position, 1.0 );',
                '  if(ps.x>=textureRange[0] && ps.x<=textureRange[2] && ps.y>=textureRange[1] && ps.y<=textureRange[3]) {',
                '     vec4 texCoord = textureMatrix*ps;',
                '     float z = orthographicDepthToViewZ(unpackRGBAToDepth(texture2DProj( depthTexture, texCoord)), depthCameraNearFar[0], depthCameraNearFar[1]);',
                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xy, z+0.05, 1.0 );',
                '  }',
                '  else {',
                '     gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );',
                '  }',
                '  #ifdef USE_SIZEATTENUATION' ,
                '    gl_PointSize = size * ( scale / - mvPosition.z );' ,
                '  #else' ,
                '    gl_PointSize = size;' ,
                '  #endif' ,
                '  #include <logdepthbuf_vertex>' ,
                '  #include <clipping_planes_vertex>' ,
                '  #include <worldpos_vertex>' ,
                '  #include <shadowmap_vertex>' ,
                '  #include <fog_vertex>' ,
                '  ',
                '}'
            ].join('\n'),

            fragmentShader: [
                'uniform vec3 diffuse;' ,
                'uniform float opacity;' ,
                '#include <common>' ,
                '#include <packing>' ,
                '#include <color_pars_fragment>' ,
                '#include <map_particle_pars_fragment>' ,
                '#include <fog_pars_fragment>' ,
                '#include <shadowmap_pars_fragment>' ,
                '#include <logdepthbuf_pars_fragment>' ,
                '#include <clipping_planes_pars_fragment>' ,
                'void main() {' ,
                '  #include <clipping_planes_fragment>' ,
                '  vec3 outgoingLight = vec3( 0.0 );' ,
                '  vec4 diffuseColor = vec4( diffuse, opacity );' ,
                '  #include <logdepthbuf_fragment>' ,
                '  #include <map_particle_fragment>' ,
                '  #include <color_fragment>' ,
                '  #include <alphatest_fragment>' ,
                '  outgoingLight = diffuseColor.rgb;' ,
                '  gl_FragColor = vec4( outgoingLight, diffuseColor.a );' ,
                '  #include <premultiplied_alpha_fragment>' ,
                '  #include <tonemapping_fragment>' ,
                '  #include <encodings_fragment>' ,
                '  #include <fog_fragment>' ,
                '}'
            ].join('\n')
        } );
    }

}


export {FitTerrainMaterial};
